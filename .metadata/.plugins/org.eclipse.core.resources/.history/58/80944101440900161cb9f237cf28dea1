package data.alg.arthur;

import java.math.BigDecimal;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import dao.databean.arthur.BoF;
import dao.databean.arthur.FiveTuple;
import dao.databean.arthur.FlowFeatureVector;
import dao.databean.arthur.IPPacket;
import dao.databean.arthur.NetworkFlow;
import dao.databean.arthur.ThreeTuple;

public class DataTransAlgorithm {

	/*
	 * private ThreeTuple _3tuple; // can be used as id
	 * 
	 * private int size_packet;// number of packets transferred in unidirection
	 * private int size_bytes; // volume of bytes transferred in unidirection
	 * 
	 * private int min_size; // min of packet size 
	 * private int max_size; // max of packet size 
	 * private float mean_size; // mean of packet size
	 * private float stdDev_size; // Std Dev. of packet size
	 * 
	 * private int min_time; // min of arriving time 
	 * private int max_time; //max of arriving time
	 * private float mean_time; // mean of arriving time
	 * private float stdDev_time; // Std Dev. of arriving time
	 */
	public static FlowFeatureVector getFlowFeatureVector(NetworkFlow netFlow) {
		FlowFeatureVector ffVector = new FlowFeatureVector();

		return ffVector;
	}

	public static ThreeTuple get3tuple(NetworkFlow netflow) {
		FiveTuple _5tuple = netflow.get_5tuple();
		ThreeTuple _3tuple = new ThreeTuple(_5tuple.getDesAddress(), _5tuple.getDesPort(), _5tuple.getProtocol());
		return _3tuple;
	}

	public static int getSize_packet(NetworkFlow netflow) {
		return netflow.getPacketList().size();
	}

	public static int getSize_bytes(NetworkFlow netflow) {
		int size = 0;
		for (IPPacket p : netflow.getPacketList()) {
			size += p.getSize();
		}
		return size;
	}
	/**
	 * 
	 * @param NetworkFlow netflow
	 * @return Object[]: int_min int_max float_mean float_stdDev
	 */
	public static Object[] getMinMaxMeanStd_DevOfSizeInfo(NetworkFlow netflow){
		Object[] sizeInfos = new Object[4];
		int min = Integer.MAX_VALUE,max = 0;
		float mean = 0, stdDev = 0;
		for(IPPacket p: netflow.getPacketList()){
			mean += p.getSize();
			if(min>p.getSize())
				min = p.getSize();
			if(max<p.getSize())
				max = p.getSize();
		}
		mean /= netflow.getPacketList().size();
		for(IPPacket p: netflow.getPacketList()){
			stdDev+=Math.sqrt(p.getSize()-mean);
		}
		stdDev = (float) Math.pow(stdDev/netflow.getPacketList().size(), 2);
		sizeInfos[0] = min;
		sizeInfos[1] = max;
		sizeInfos[2] = mean;
		sizeInfos[3] = stdDev;
		return sizeInfos;
	}
	//!!!!!!!!use BigDecemal later!!!!!!!!!
	public static Object[] getMinMaxMeanStd_DevTimeInfo(NetworkFlow netflow){
		Object[] timeInfos = new Object[4];
		long min = Long.MAX_VALUE,max = 0;
		float mean = 0, stdDev = 0;
		for(IPPacket p: netflow.getPacketList()){
			mean += p.getArriveTime();
			if(min>p.getArriveTime())
				min = p.getArriveTime();
			if(max<p.getArriveTime())
				max = p.getArriveTime();
		}
		mean /= netflow.getPacketList().size();
		for(IPPacket p: netflow.getPacketList()){
			stdDev+=Math.sqrt(p.getArriveTime()-mean);
		}
		stdDev = (float) Math.pow(stdDev/netflow.getPacketList().size(), 2);
		timeInfos[0] = min;
		timeInfos[1] = max;
		timeInfos[2] = mean;
		timeInfos[3] = stdDev;
		return timeInfos;
	}
	
	public static BoF correlationAnalysis(List<FlowFeatureVector> vecList) {
		BoF bof = new BoF();
		return bof;
	}

	// !!!!!!!!!!!!!!!!!TIME DISTANCE IS NOT CONCERNED!!!!!!!!!!!!!!!!!!!!!!!
	public static Map<Integer, NetworkFlow> packets2NetworkFlow(List<IPPacket> packets) {
		Map<Integer, NetworkFlow> map = new HashMap<Integer, NetworkFlow>();
		for (IPPacket p : packets) {
			int hashcode = p.get_5tuple().hashCode();
			NetworkFlow flow = getNetworkFlowBy5THsah(hashcode, map);
			if (flow == null) {
				flow = new NetworkFlow();
				flow.set_5tuple(p.get_5tuple());
				LinkedList<IPPacket> l = new LinkedList<IPPacket>();
				l.add(p);
				flow.setPacketList(l);
				map.put(new Integer(hashcode), flow);
			}
		}
		return map;
	}

	public static List<NetworkFlow> packets2NetworkFlowl(List<IPPacket> packets) {
		List<NetworkFlow> flowList = new LinkedList<NetworkFlow>();
		for (IPPacket p : packets) {
			int hashcode = p.get_5tuple().hashCode();
			NetworkFlow flow = getNetworkFlowBy5THsah(hashcode, flowList);
			if (flow == null) {
				flow = new NetworkFlow();
				flow.set_5tuple(p.get_5tuple());
				LinkedList<IPPacket> l = new LinkedList<IPPacket>();
				l.add(p);
				flow.setPacketList(l);
				flowList.add(flow);
			}
		}
		return flowList;
	}

	private static NetworkFlow getNetworkFlowBy5THsah(int hashcode, Map<Integer, NetworkFlow> flowMap) {
		if (flowMap.size() == 0 && !flowMap.containsKey(new Integer(hashcode))) {
			return null;
		}
		NetworkFlow nf = flowMap.get(new Integer(hashcode));
		return nf;
	}

	private static NetworkFlow getNetworkFlowBy5THsah(int hashcode, List<NetworkFlow> flowList) {
		if (flowList.size() == 0) {
			return null;
		}
		for (NetworkFlow flow : flowList) {
			if (flow.get_5tuple().hashCode() == hashcode) {
				return flow;
			}
		}
		return null;
	}
}
